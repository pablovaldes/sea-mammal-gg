{
    "contents" : "## Explore magnetometer data using rgl and ggplot2.\nlibrary(rgl)\nlibrary(lubridate)  # Helpful package for dealing with dates.\nlibrary(ggplot2)\nlibrary(scales)  # Needed to make a manual (cosine) scale\n\n## Load data\nload('Data/dat2_ful.RData')   # Takes <10 seconds\n(n <- nrow(dat2_ful))  # On the bigger side...\n\n## Take a look:\nhead(dat2_ful)\n\n##\n## 1. 3D viewing with rgl\n##\n\n## (A) Let's see the accelerometer data (aX, aY, aZ).\nwith(dat2_ful, plot3d(aX, aY, aZ))  # Fairly quick!\n\n## It's way too overplotted, can't see what's going on in the middle. Let's both:\n##  1. subset the data, and\n##  2. add alpha-transparency (my favourite way to deal with overplotting)\nfrac <- 1/500\nsubdat <- dat2_ful[1:(n*frac)/frac, ]\nwith(subdat, plot3d(aX, aY, aZ, alpha = 0.2))\n## Notice the two \"rings\".\n\n## Let's \"add an aesthetic\": view time as colour (higher frequency colours =>\n##  later dates)\nqplot(26:31, 1, colour = I(rainbow(6)), size = I(10)) +    # Quick legend\n    xlab(\"Date\") + ylab(\"\")\nwith(subdat, plot3d(aX, aY, aZ, alpha = 0.2, col=rainbow(nrow(subdat))))\naxis3d('x',pos=c(NA, 0, 0))\naxis3d('y',pos=c(0, NA, 0))\naxis3d('z',pos=c(0, 0, NA))\n\n## Any pattern by connecting-the-dots?\nwith(subdat, plot3d(aX, aY, aZ, type = \"l\", alpha = 0.1))  # Nope.\n\n## (B) Let's see the magnetometer data (mX, mY, mZ).\nwith(dat2_ful, plot3d(mX, mY, mZ)) \n\n## Deal with overplotting, and add colour:\nwith(subdat, plot3d(mX, mY, mZ, alpha = 0.2, col=rainbow(nrow(subdat))))\naxis3d('x',pos=c(NA, 0, 0))\naxis3d('y',pos=c(0, NA, 0))\naxis3d('z',pos=c(0, 0, NA))\n## Most of the data are on the surface of the \"egg\".\n\n## Any pattern by connecting-the-dots?\nwith(subdat, plot3d(mX, mY, mZ, type = \"l\", alpha = 0.1))  # Nope.\n\n##\n## 2. View Magnetometer data in 2D with ggplot2\n##\n\n## We can reduce the magnetometer data to spherical coordinates, of which\n##  two dimensions are informative -- the angles, which are analagous\n##  to latitude and longitude on the earth. After transforming the data,\n##  we'll progress from a basic scatterplot to a more informative plot,\n##  using most components of the grammar of graphics.\n\n## Preliminaries ---------\n\n## Convert rectangular to spherical coords.\n## The new coordinates are: \n##  'angle_lon' -- angle in (0,360) or (0, 2*pi) on the xy-plane (similar\n##    to longitude, hence the name)\n##  'angle_lat' -- angle in (-90,90) or (-pi/2, pi/2) away from the xy-plane\n##    (similar to latitude, hence the name)\n##  'r' -- distance from the origin.\nrec2pol <- function(x, y, z, degrees = TRUE){\n    res <- data.frame(angle_lon = atan(y/x) + pi*(x<=0) + 2*pi*(x>0 & y<0),\n                      angle_lat = atan(z / sqrt(x^2 + y^2)),\n                      r = sqrt(x^2 + y^2 + z^2)) \n    if (degrees) res[, 1:2] <- res[, 1:2] * 180/pi\n    res\n}\nspheric <- with(dat2_ful, cbind(time, rec2pol(mX, mY, mZ)))\nhead(spheric)\n\n## Add \"hemisphere\" -- it'll come in handy later\nhemi <- rep(NA, nrow(spheric))\nhemi[spheric$angle_lat < 0] <- \"Lower 'Hemisphere'\"  # Below xy-plane\nhemi[spheric$angle_lat >= 0] <- \"Upper 'Hemisphere'\" # Above xy-plane\nspheric$hemisphere <- hemi\n\n## Note: ggplot seems to be having a hard time putting dates on the colour\n##   scale, as we'll do later. So I'll convert the dates to something \n##   continuous (seconds; POSIXct).\nspheric$sec <- as.numeric(spheric$time)\n\n## Subset the data:\nfrac <- 1/100\nsubspheric <- spheric[1:(n*frac)/frac, ]\n\n## We can see that the data don't lie perfectly on a sphere. This may suggest\n##  that the data need calibrating, but it's good enough for our purposes.\n## (Use *statistical transformation* of the data to see distribution of r)\n#### \"Count\" transform for histogram.\nqplot(r, data = subspheric, binwidth = 1)\n#### \"Density\" transform for kernel density plots.\nggplot(subspheric, aes(r)) +\n    geom_density(aes(group = hemisphere, fill = hemisphere), alpha = 0.25)\n\n## (I) Basic scatterplot ---------\n\n## Display the two spherical angles as a scatterplot.\nggplot(subspheric, aes(angle_lon, angle_lat, colour = sec)) +\n    geom_point(alpha = 0.2)\n\n## Would like to change the colour scale (and the labels)\n## Need to know about grammar component #3: scales.\n\n## (II) Add rainbow colour scale to the plot ---------\n\n## Make a manual scale:\n#### Change the labels \nscale_dates <- unique(day(subspheric$time))\nmy_labs <- paste(\"Aug.\", scale_dates)  # The labels I want on the scale.\nmy_breaks <- as.integer(ymd_hms(paste0(\"2011-08-\", scale_dates, \" 00:00:00\"))) \n    # Breaks are *where* on the scale I want to put labels.\n\n#### Construct the scale:\ndate_legend <- scale_colour_gradientn(\"Date\",\n                                      colours = rainbow(7),\n                                      breaks = my_breaks,\n                                      labels = my_labs)\n## Add scale to the scatterplot\nggplot(subspheric, aes(angle_lon, angle_lat, colour = sec)) +\n    geom_point(alpha = 0.2) +\n    date_legend\n\n## Nice, but the upper portion (at 90 degrees) actually represents one point.\n##  Likewise with the lower portion (at -90 degrees).\n\n## Solution: convert to polar coordinates.\n##  We'll use grammar component #4: \"coordinates\"\n\n## (III) Change to polar coordinates ---------\n\np <- ggplot(subspheric, aes(angle_lon, abs(angle_lat))) +\n    coord_polar() +\n    date_legend +\n    ylab(\"Inclination / Declination\\n(degrees)\") +\n    scale_x_continuous(\"Bearing (degrees)\", \n                       breaks = 0:7*45, \n                       limits = c(0, 360))\n\np + geom_point(aes(colour = sec), alpha = 0.1) + \n    scale_y_reverse()\n\n## Now it would be nice to differentiate between points above the xy-plane\n##  and below the xy-plane -- use the \"hemisphere\" variable created.\n##  Grammar component being used: *layering/facetting*.\n\n## (IV) Add facetting for different \"hemispheres\" ---------\n\np + facet_wrap(~ hemisphere) +\n    geom_point(aes(colour = sec), alpha = 0.1) + \n    scale_y_reverse()\n\n## (V) Final touches ---------\n\n## Would be nice to:\n##  1. Spread out the center -- cosine *scale* transform would be ideal, since\n##       that provides a projection of the sphere onto the plane.\n##  2. Make \"upper hemisphere\" less translucent, via *aesthetics* (since it's\n##       less crowded)\nmy_cosine <- trans_new(\"my_cos\", \n                       transform = function(y) cos(y*pi/180), \n                       inverse = function(theta) acos(theta)*180/pi)\np + facet_wrap(~ hemisphere) +\n    geom_point(aes(colour = sec, alpha = hemisphere)) + # Notice alpha is in aes\n    scale_y_continuous(trans = my_cosine) +\n    scale_alpha_discrete(range = c(0.1, 0.3), guide=FALSE)\n",
    "created" : 1430646273716.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "2103261989",
    "id" : "C0E0A037",
    "lastKnownWriteTime" : 1431149036,
    "path" : "~/Documents/ActiveProjects/SMTG_vis/gg_demo/2-mag_data.R",
    "project_path" : "2-mag_data.R",
    "properties" : {
        "tempName" : "Untitled1"
    },
    "source_on_save" : false,
    "type" : "r_source"
}